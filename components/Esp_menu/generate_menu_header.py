# Esp_menu/generate_menu_header.py

import json
import os
import sys

def generate_menu_header(json_file_arg, header_file):
    """
    Generates a C header file from a JSON configuration file for an LVGL-based menu system.

    Args:
        json_file_arg (str): The relative path to the JSON file from the script's directory,
                             or an absolute path provided via command line.
        header_file (str): The full path of the output C header file to be generated.

    The function performs the following steps:
    1. Determines the absolute path to the JSON file based on the script location or argument.
    2. Validates the existence of the JSON file and loads its content.
    3. Parses the JSON data to generate LVGL object creation and data structure code.
    4. Writes the generated code to the specified header file.

    The generated header file includes:
    - Definitions for menu-related LVGL objects and styles.
    - A data structure (`menu_item_t`) for menu items.
    - An array (`menu_items_data`) to hold menu item data.

    Notes:
        - The JSON file must follow a specific structure, including "type" and "items" fields.
        - If the JSON file is invalid or cannot be decoded, the function will print an error and exit.

    Example:
        generate_menu_header("menu_config.json", "/path/to/output/menu_data.h")
    """
    # Determine the absolute path of the JSON file
    # If the provided path is absolute, use it directly.
    # Otherwise, assume it's relative to the script's directory.
    if os.path.isabs(json_file_arg):
        json_path = json_file_arg
    else:
        script_dir = os.path.dirname(os.path.realpath(__file__))
        json_path = os.path.join(script_dir, json_file_arg)

    print(f"Looking for JSON file at: {json_path}")
    if not os.path.exists(json_path):
        print(f"Error: JSON file not found at {json_path}!")
        sys.exit(1) # Exit if JSON not found

    # Use the second argument (header_file) as the full output path
    print(f"Writing header file to: {header_file}")

    # Ensure the output directory exists
    output_dir = os.path.dirname(header_file)
    if output_dir: # Check if dirname returned something (not empty for relative paths in cwd)
        os.makedirs(output_dir, exist_ok=True)

    try:
        with open(json_path, 'r') as f:
            try:
                data = json.load(f)
                print("JSON data loaded successfully.")
            except json.JSONDecodeError as e:
                print(f"Error decoding JSON from {json_path}: {e}")
                sys.exit(1) # Exit on JSON decode error

        with open(header_file, 'w') as h:
            h.write('// Auto-generated by generate_menu_header.py. DO NOT EDIT.\n\n')
            h.write('#ifndef MENU_DATA_H\n')
            h.write('#define MENU_DATA_H\n\n')
            h.write('#include <stdint.h>\n')
            # Conditionally include lvgl.h if needed, or assume it's included elsewhere
            # h.write('#include "lvgl.h"\n\n') # Assuming lv_obj_t is needed, otherwise remove

            # Define lv_obj_t as void* if lvgl.h is not included here to avoid compilation errors
            # if the header is included in C files that don't see the full LVGL definition.
            # A better approach might be to ensure lvgl.h is included before this header in C files.
            h.write('// Forward declare lv_obj_t if lvgl.h is not included here\n')
            h.write('// typedef struct _lv_obj_t lv_obj_t;\n\n')


            # Generate data structure definition
            h.write('typedef struct {\n')
            h.write('    void *object; // Changed to void* for flexibility if lv_obj_t isn\'t defined here\n')
            h.write('    const char *label;\n')
            h.write('    const char *variable; // Associated variable name (e.g., for NVS)\n')
            h.write('    const char **values;  // Array of possible string values (NULL terminated)\n')
            h.write('    float min;            // Minimum value for numerical parameters\n')
            h.write('    float max;            // Maximum value for numerical parameters\n')
            h.write('    float step;           // Step value for numerical parameters\n')
            h.write('} menu_item_t;\n\n')

            # Generate the data array
            h.write('// Array containing the menu structure data\n')
            h.write('static const menu_item_t menu_items_data[] = {\n') # Made static const

            for item in data:
                if item["type"] == "menu":
                    # Add the menu container itself (label only)
                    h.write('    { NULL, "%s", NULL, NULL, 0, 0, 0 }, // Menu Label\n' % item["label"])
                    # Add its sub-items
                    for sub_item in item.get("items", []): # Use .get for safety
                        if sub_item["type"] == "parameter":
                            values = sub_item.get("values", [])
                            # --- CORRECTED BLOCK for sub-item values ---
                            if not values:
                                values_str = "NULL"
                            else:
                                # 1. Create the comma-separated list of quoted strings first
                                quoted_values = ", ".join([f'"{v}"' for v in values])
                                # 2. Now create the C array string using an f-string
                                #    Use {{{{ and }}}} for the C braces {{ and }}
                                values_str = f'(const char *[]){{{{{quoted_values}, NULL}}}}'
                            # --- END CORRECTED BLOCK ---

                            h.write('    { NULL, "%s", "%s", %s, %f, %f, %f }, // Parameter\n' % (
                                sub_item.get("label", ""), # Use .get for safety
                                sub_item.get("variable", ""), # Use .get for safety
                                values_str,
                                sub_item.get("min", 0.0),
                                sub_item.get("max", 0.0),
                                sub_item.get("step", 0.0),
                            ))
                        # Add handling for other sub_item types if necessary
                        # elif sub_item["type"] == "action":
                        #    h.write('    { NULL, "%s", "%s", NULL, 0, 0, 0 }, // Action\n' % (
                        #        sub_item.get("label", ""),
                        #        sub_item.get("action_id", "") # Example: identifier for action
                        #    ))

            # Handle top-level parameters (outside any "menu" block)
                elif item["type"] == "parameter":
                    values = item.get("values", [])
                    # --- CORRECTED BLOCK for top-level item values ---
                    if not values:
                        values_str = "NULL"
                    else:
                        # 1. Create the comma-separated list of quoted strings first
                        quoted_values = ", ".join([f'"{v}"' for v in values])
                        # 2. Now create the C array string using an f-string
                        #    Use {{{{ and }}}} for the C braces {{ and }}
                        values_str = f'(const char *[]){{{{{quoted_values}, NULL}}}}'
                    # --- END CORRECTED BLOCK ---

                h.write('    { NULL, "%s", "%s", %s, %f, %f, %f }, // Top-Level Parameter\n' % (
                    item.get("label", ""), # Use .get for safety
                    item.get("variable", ""), # Use .get for safety
                    values_str,
                    item.get("min", 0.0),
                    item.get("max", 0.0),
                    item.get("step", 0.0),
                ))
            # Add handling for other top-level types if necessary

            h.write('};\n\n')
            h.write('#define MENU_ITEM_COUNT (sizeof(menu_items_data) / sizeof(menu_items_data[0]))\n\n')
            h.write('#endif // MENU_DATA_H\n')

        print(f"Header file '{header_file}' generated successfully.")

    except IOError as e:
        print(f"Error writing to header file {header_file}: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        sys.exit(1)


if __name__ == '__main__':
    # Use command-line arguments for flexibility
    if len(sys.argv) != 3:
        print("Usage: python generate_menu_header.py <input_json> <output_header>")
        print("  <input_json>: Path to the menu definition JSON file.")
        print("  <output_header>: Full path for the generated C header file.")
        sys.exit(1)

    # Pass arguments directly to the function
    generate_menu_header(sys.argv[1], sys.argv[2])
